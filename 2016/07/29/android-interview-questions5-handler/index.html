<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="android," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="前言
Handler是Android消息机制的上层接口，平时使用起来很方便，我们可以通过它把一个任务切换到Handler所在的线程中去运行。而最常用的就是拿来从子线程切换到主线程以便更新UI。关于Android的消息机制无法以题目为导向来进行讲解，面试中可能会问关于Handler、Looper、MessageQueue、Message之间的关系，要完整回答，我们需要了解Handler内部是如何工作">
<meta property="og:type" content="article">
<meta property="og:title" content="Android面试题（五）———— Android的消息机制">
<meta property="og:url" content="http://yoursite.com/2016/07/29/android-interview-questions5-handler/index.html">
<meta property="og:site_name" content="YOXIN">
<meta property="og:description" content="前言
Handler是Android消息机制的上层接口，平时使用起来很方便，我们可以通过它把一个任务切换到Handler所在的线程中去运行。而最常用的就是拿来从子线程切换到主线程以便更新UI。关于Android的消息机制无法以题目为导向来进行讲解，面试中可能会问关于Handler、Looper、MessageQueue、Message之间的关系，要完整回答，我们需要了解Handler内部是如何工作">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1944615-ab957f88bd15af1f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1944615-6c0480425efe8037.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1944615-7e31bbb3c02c14aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2016-08-01T05:28:12.416Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android面试题（五）———— Android的消息机制">
<meta name="twitter:description" content="前言
Handler是Android消息机制的上层接口，平时使用起来很方便，我们可以通过它把一个任务切换到Handler所在的线程中去运行。而最常用的就是拿来从子线程切换到主线程以便更新UI。关于Android的消息机制无法以题目为导向来进行讲解，面试中可能会问关于Handler、Looper、MessageQueue、Message之间的关系，要完整回答，我们需要了解Handler内部是如何工作">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1944615-ab957f88bd15af1f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/07/29/android-interview-questions5-handler/"/>

  <title> Android面试题（五）———— Android的消息机制 | YOXIN </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?19323191134e5eefe2d83553db75255d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">YOXIN</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">郑永欣的个人博客</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android面试题（五）———— Android的消息机制
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-29T09:45:47+08:00" content="2016-07-29">
              2016-07-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/29/android-interview-questions5-handler/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/29/android-interview-questions5-handler/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
             <span id="/2016/07/29/android-interview-questions5-handler/" class="leancloud_visitors" data-flag-title="Android面试题（五）———— Android的消息机制">
               &nbsp; | &nbsp;
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               <span class="post-meta-item-text">阅读次数 </span>
               <span class="leancloud-visitors-count"></span>
              </span>
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>Handler是Android消息机制的上层接口，平时使用起来很方便，我们可以通过它把一个任务切换到Handler所在的线程中去运行。而最常用的就是拿来从子线程切换到主线程以便更新UI。关于Android的消息机制无法以题目为导向来进行讲解，面试中可能会问关于<strong>Handler、Looper、MessageQueue、Message之间的关系</strong>，要完整回答，我们需要了解Handler内部是如何工作的，而这一部分的源码并不复杂。所以先整体分析得出结论，再从源码中验证结论。<br><a id="more"></a></p>
<h2 id="Android的消息机制整体剖析"><a href="#Android的消息机制整体剖析" class="headerlink" title="Android的消息机制整体剖析"></a>Android的消息机制整体剖析</h2><hr>
<p>Android的消息机制工作原理大致如下：<br><img src="http://upload-images.jianshu.io/upload_images/1944615-ab957f88bd15af1f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android消息机制.jpg"></p>
<ol>
<li><p><strong>MessageQueue</strong>：它的内部存储了一组数据，以队列的形式向外提供了插入和删除的工作。但是它的内部实现并不是队列，而是单链表。对应图中<strong>长方形格子</strong></p>
</li>
<li><p><strong>Looper</strong>：在Handler的内部，会不停检查是否有新的消息，如果有就调用最终消息中的Runnable或者Handler的handleMessage方法。对应<strong>提取并处理消息</strong>。</p>
</li>
<li><p><strong>Handler</strong>：Handler的工作主要包含消息的发送和接收过程。消息的发送可以通过post的一系列方法以及send的一系列方法来实现，不过最后都是通过send的一系列方法实现的。对应<strong>添加消息</strong>和<strong>处理线程</strong>。</p>
</li>
<li><p><strong>Message</strong>：封装了需要传递的消息，并且本身可以作为链表的一个节点，方便MessageQueue的存储。</p>
</li>
<li><p><strong>ThreadLocal</strong>：一个线程内部的数据存储类，通过它可以在指定的线程中储存数据，而其它线程无法获取到。在Looper、AMS中都有使用。</p>
</li>
<li><p><strong>Thread</strong>：Android的线程类</p>
</li>
</ol>
<p>Android消息机制的类的关系总结如下：<br><img src="http://upload-images.jianshu.io/upload_images/1944615-6c0480425efe8037.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android消息机制的类的关系UML图"><br>由上图总结出以下结论：</p>
<ol>
<li><p>MessageQueue持有一个mMessages，作为消息队列内部存储数据的链表头。它具有两个重要的操作：对消息的插入和读取，对应的方法分别是enqueueMessage和next。其中enqueueMessage是往消息队列中插入一条信息，而next的作用是从消息队列中取出一条信息并将其从消息队列中移除。</p>
</li>
<li><p>Message内部除了obj，what，arg1，arg2等存储数据的成员，还有一个可以指向其他Message的指针，所以MessageQueue可以使用它来作为链表的节点。</p>
</li>
<li><p>Looper内部持有一个消息队列、线程、主线程、ThreadLocal。主要的方法有：</p>
<ul>
<li>prepare：为当前线程创建一个Looper。</li>
<li>quit：退出Looper，Looper退出后，Handler的send方法会返回false，在子线程手动创建的Looper最好在不需要的时候终止掉。</li>
<li>quitSafely：把消息队列中已有的消息处理完毕后退出。</li>
<li>getMainLooper：在任何地方获取主线程的Looper。</li>
<li>getLooper：获取当前线程的Looper。</li>
<li>loop：最重要的一个方法，只有调用了loop方法后，消息循环系统才能起作用。（后面再做详细解释）</li>
</ul>
</li>
<li><p>一个Thread只能持有一个Looper。</p>
</li>
<li><p>Handler持有一个消息队列、Looper、Callback。提供多种创建方法，默认的Handler()将使用当前线程的Looper，如果当前线程没有Looper会抛出异常，也可以通过传参指定Looper。sendMessage方法可以往消息队列添加消息。handleMessage方法在创建Handler的线程中或者指定的Looper持有的线程中处理消息。</p>
</li>
<li><p>一个Looper可以被多个Handler持有</p>
</li>
<li><p>ThreadLocal的get和set方法操作的数据，在每个线程中是相互独立，互不干扰的。</p>
</li>
</ol>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><hr>
<h3 id="1-ThreadLocal的工作原理"><a href="#1-ThreadLocal的工作原理" class="headerlink" title="1. ThreadLocal的工作原理"></a>1. ThreadLocal的工作原理</h3><ul>
<li>ThreadLocal是什么？<br>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而其它线程无法获取到数据。在Looper、ActiivtyThread和AMS中都用到了ThreadLocal。</li>
<li><p>ThreadLocal的使用场景</p>
<ul>
<li>当某些数据是以线程为作用域，并且不同线程有不同的数据副本的时候</li>
<li>复杂逻辑下的对象传递，比如监听器的传递。使用参数传递的话：当函数调用栈过深时，设计会很糟糕。为每一个线程定义一个静态变量存储监听器，如果是多线程的话，一个线程就需要定义一个静态变量，无法扩展，这时候使用ThreadLocal可以解决问题。</li>
</ul>
<p>从ThreadLocal的set和get方法可以看出，他们所操作的对象都是当前线程的localValues对象的table数组，因此在不同的线程访问ThreadLocal的set和get方法，他们对ThreadLocal的读写操作都是仅限于各自线程的内部。这就是ThreadLocal可以在多个线程中互不干扰地存储和修改数据的原因。<br>简单来讲：就是每个线程都可以操作ThreadLocal，但他们操作的数据是分隔开的，互不干扰的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = new ThreadLocal&lt;Boolean&gt;();</span><br><span class="line"></span><br><span class="line">mBooleanThreadLocal.set(true);</span><br><span class="line">Log.d(TAG, &quot;[Thread#main]mBooleanThreadLocal=&quot;+ mBooleanThreadLocal.get());</span><br><span class="line"></span><br><span class="line">new Thread(&quot;Thread#1&quot;) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        mBooleanThreadLocal.set(false);</span><br><span class="line">        Log.d(TAG, &quot;[Thread#1]mBooleanThreadLocal=&quot;+ mBooleanThreadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line">new Thread(&quot;Thread#2&quot;) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Log.d(TAG, &quot;[Thread#2]mBooleanThreadLocal=&quot;+ mBooleanThreadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">07-17 16:23:23.222 23286-23286/com.ryg.chapter_15 D/MainActivity: [Thread#main]mBooleanThreadLocal=true</span><br><span class="line">07-17 16:23:23.222 23286-23312/com.ryg.chapter_15 D/MainActivity: [Thread#1]mBooleanThreadLocal=false</span><br><span class="line">07-17 16:23:23.222 23286-23313/com.ryg.chapter_15 D/MainActivity: [Thread#2]mBooleanThreadLocal=null</span><br></pre></td></tr></table></figure></p>
<p>由此可以得出<strong>结论7</strong>是正确的。</p>
<h3 id="2-消息队列的工作原理"><a href="#2-消息队列的工作原理" class="headerlink" title="2. 消息队列的工作原理"></a>2. 消息队列的工作原理</h3><p>  消息队列在Android中指的是MessageQueue，它主要包含两个操作：插入和读取。读取操作本身会伴随着删除操作。插入和删除对应的方法分别为enqueueMessage和next。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">    ...</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        ...</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        boolean needWake;</span><br><span class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">            // New head, wake up the event queue if blocked.</span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">            // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">            // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; // invariant: p == prev.next</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">        if (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从enqueueMessage的实现中，我们可以明显看出这是一个单链表的插入操作，不多解释，接着看next方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">    int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">    int nextPollTimeoutMillis = 0;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // We can assume mPtr != 0 because the loop is obviously still running.</span><br><span class="line">        // The looper will not call this method after the loop quits.</span><br><span class="line">        nativePollOnce(mPtr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            // 尝试获取一个消息，如果找到就返回它。</span><br><span class="line">            final long now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = null;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                do &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            if (msg != null) &#123;</span><br><span class="line">                if (now &lt; msg.when) &#123;</span><br><span class="line">                    // Next message is not ready.  Set a timeout to wake up when it is ready.</span><br><span class="line">                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    // Got a message.</span><br><span class="line">                    mBlocked = false;</span><br><span class="line">                    if (prevMsg != null) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = null;</span><br><span class="line">                    if (false) Log.v(&quot;MessageQueue&quot;, &quot;Returning message: &quot; + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    return msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // No more messages.</span><br><span class="line">                nextPollTimeoutMillis = -1;</span><br><span class="line">            &#125;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>next方法是一个无限循环的方法，如果消息队列中没有消息，那么next方法会一直阻塞在这里。当有新消息到来时，next方法会返回这条消息并将其从单链表中移除。</p>
<h3 id="3-Looper的工作原理"><a href="#3-Looper的工作原理" class="headerlink" title="3. Looper的工作原理"></a>3. Looper的工作原理</h3><p>Looper在Android消息机制中扮演消息循环的角色，它会不停地从MessageQueue中查看是否有新消息，如果有就立即处理，没有就阻塞在那里。现在，我们从Looper的使用的一个常见例子来分析这个Looper类。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LooperThread extends Thread &#123;</span><br><span class="line">    public Handler h;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 1. 调用prepare</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        // 2.进入消息循环 </span><br><span class="line">        Looper.loop();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 应用程序使用LooperThread</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    new LooperThread().start(); //启动新线程，线程函数是run</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面代码中，Looper有两处关键调用，分别是1. 调用prepare 2.进入消息循环。接下来我们重点分析这两个函数。</p>
<ol>
<li>第一个调用的函数是Looper的prepare函数。代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void prepare() &#123;</span><br><span class="line">    prepare(true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">    // 一个线程中只能有一个Looper。只能调用一次prepare</span><br><span class="line">    if (sThreadLocal.get() != null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 构造一个Looper对象，设置到调用线程的局部变量中。</span><br><span class="line">    sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line">// sThreadLocal的定义</span><br><span class="line">static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>根据上面对ThreadLocal的分析，我们知道使用局部变量sThreadLocal存储的变量作用域是针对线程的。即通过prepare为调用的线程的设置了一个Looper对象。在看一看Looper的构造方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">    mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在构造方法中，创建了一个新的消息队列，和持有当前线程的引用。<br>所以prepare函数主要完成的工作是：<strong>在调用prepare的线程中，设置一个Looper对象，这个Looper对象保存在Thread的localValues中，而Looper对象内部封装了一个消息队列。</strong><br>prepare通过ThreadLocal机制，巧妙地将Looper和调用线程关联在一块。接着看第二个重要函数loop。</p>
<ol>
<li>Looper的循环<br>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Run the message queue in this thread. Be sure to call</span><br><span class="line"> * &#123;@link #quit()&#125; to end the loop.</span><br><span class="line"> */</span><br><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me = myLooper(); //myLooper返回当前线程的Looper对象</span><br><span class="line">    final MessageQueue queue = me.mQueue; // 取出Looper中的消息队列</span><br><span class="line">    ...</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        // 调用该消息的Handler，交给它的dispatchMessage处理</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        ...</span><br><span class="line">        // 消息的回收，回收到消息池中。</span><br><span class="line">        msg.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>从代码中可以看出，loop是一个死循环，唯一跳出循环的条件是MessageQueue的next方法返回null。而只有当Looper调用quit或者quitSafely方法，方法内部再调用MessageQueue的quit或者quitSafely方法通知消息队列退出，当消息队列退出后，next方法才会返回null。从上面对MessageQueue的分析中，我们知道next方法是一个阻塞操作，当消息队列中没有消息时，next方法就会一直阻塞在那里，这也导致了loop方法一直阻塞在那里，直到next方法返回新的消息，才会调用msg.target.dispatchMessage(msg)来处理消息。这里的msg.target就是发送这条消息的Handler对象。需要<strong>注意</strong>的是：通过这一过程。因为Handler的dispatchMessage方法在loop中执行，所以发送消息所在的线程成功地把代码逻辑切换到了Looper所在的线程中执行，完成了线程间的切换。</p>
<h3 id="4-Handler的工作原理"><a href="#4-Handler的工作原理" class="headerlink" title="4. Handler的工作原理"></a>4. Handler的工作原理</h3><p>首先看一下Handler所包括的成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final MessageQueue mQueue; // Handler中也有一个消息队列，从mLooper中取出的</span><br><span class="line">final Looper mLooper; // 当前线程的Looper或者指定的Looper</span><br><span class="line">final Callback mCallback; //有一个回调用的类</span><br></pre></td></tr></table></figure></p>
<p>这几个变量是如何被使用的？首先分析Handler的构造方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Handler()</span><br><span class="line"></span><br><span class="line">public Handler(Callback callback)</span><br><span class="line"></span><br><span class="line">public Handler(Looper looper) </span><br><span class="line"></span><br><span class="line">public Handler(Looper looper, Callback callback)</span><br></pre></td></tr></table></figure></p>
<p>在Handler中我们常用的构造方法有上面4个，如果没有指定Callback，默认mCallback为null。如果没有指定Looper，默认使用当前线程的Looper，当前线程Looper为null时，抛出异常。mQueue是通过mLooper的myLooper方法获取的。<br>Handler的工作主要包含消息的发送和接收过程。消息的发送可以通过post的一系列方法以及send的一系列方法来实现，不过最后都是通过send的一系列方法实现的。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessage(Message msg)</span><br><span class="line">&#123;</span><br><span class="line">    return sendMessageDelayed(msg, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</span><br><span class="line">&#123;</span><br><span class="line">    if (delayMillis &lt; 0) &#123;</span><br><span class="line">        delayMillis = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    if (queue == null) &#123;</span><br><span class="line">        RuntimeException e = new RuntimeException(</span><br><span class="line">                this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target = this;</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以发现，Handler发送消息的过程不过是向消息队列插入一条消息，MessageQueue的next方法会返回这条消息给Looper，Looper收到消息会交给Handler处理，Handler的dispatchMessage方法就会被调用DispatchMessage的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1944615-7e31bbb3c02c14aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler消息处理流程图"><br>dispatchMessage会先调用Message的callback接口，在调用Handler的Callback，最后调用handlerMessage方法。</p>
<h2 id="Handler的实际应用"><a href="#Handler的实际应用" class="headerlink" title="Handler的实际应用"></a>Handler的实际应用</h2><hr>
<h3 id="1-Looper和Handler的同步关系"><a href="#1-Looper和Handler的同步关系" class="headerlink" title="1. Looper和Handler的同步关系"></a>1. Looper和Handler的同步关系</h3><p>Looper和Handler会有什么同步关系呢？它们之间存在的同步关系跟多线程有关，如果不注意，就容易引起错误。<br>下面看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class LooperThread extends Thread &#123;</span><br><span class="line">    public Looper myLooper = null;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123; // 假使run在线程2中执行</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        myLooper = Looper.myLooper();</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 假使下面代码在线程1中运行</span><br><span class="line">&#123;</span><br><span class="line">    LooperThread thread2 = new LooperThread();</span><br><span class="line">    thread2.start();</span><br><span class="line">    Looper looper = thread2.myLooper;</span><br><span class="line">    Handler thread1Hanlder = new Handler(looper);</span><br><span class="line">    thread1Hanlder.sendEmptyMessage(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码的作用：</p>
<ul>
<li>在线程1中创建线程2，并且线程2通过Looper处理消息。</li>
<li>线程1中得到线程2的Looper，并且根据这个Looper创建一个Handler，这样发送给该Handler的消息将由线程2处理。<br>理想是美好的，现实是残酷的。如果我们熟悉多线程，就很容易发现这段代码中存在巨大漏洞，需要注意的是：myLooper的赋值是在线程2的run方法中，而looper的赋值又是在线程1中，这样就可能导致线程2的run函数还没来得及给myLooper赋值，线程1中的looper就取得了myLooper的初值，即looper等于null。<br>解决这个问题，只需要在其中加入线程锁就可以了。不过不用我们自己动手，Android已经为这个问题提供了解决方案，那就是HandlerThread。<br>HandlerThread可以完美解决myLooper可能为空的问题。直接上代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public Looper getLooper() &#123;</span><br><span class="line">    if (!isAlive()) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // If the thread has been started, wait until the looper has been created.</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        while (isAlive() &amp;&amp; mLooper == null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return mLooper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    mTid = Process.myTid();</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    Process.setThreadPriority(mPriority);</span><br><span class="line">    onLooperPrepared();</span><br><span class="line">    Looper.loop();</span><br><span class="line">    mTid = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>HanderThread很简单，使用wait/notifyAll就解决了这个问题。</p>
<h3 id="2-小心内存泄露"><a href="#2-小心内存泄露" class="headerlink" title="2. 小心内存泄露"></a>2. 小心内存泄露</h3><p>Handler的使用是有可能引起内存泄露的，先看一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private TextView mTextView;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        mTextView = new TextView(this);</span><br><span class="line">        mTextView.setText(&quot;内存泄露?&quot;);</span><br><span class="line">        setContentView(mTextView);</span><br><span class="line">        MyHandler handler = new MyHandler(mTextView);</span><br><span class="line">        handler.sendEmptyMessage(0x11);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Handler handler = new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            mTextView.setText(&quot;有内存泄露&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码如果是在Android Studio中编写，Android Lint会提示可能存在内存泄露，并提供相应的解决方案：</p>
<blockquote>
<p>This Handler class should be static or leaks might occur (anonymous android.os.Handler) less… (Ctrl+F1)<br>Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue. If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows: Declare the Handler as a static class; In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler; Make all references to members of the outer class using the WeakReference object.</p>
</blockquote>
<p>  这段话的大概意思是：这个Handler应该声明为静态的，否则可能导致内存泄露。当Handler声明为内部类时，他可能持有外部类的引用。如果这时Handler使用一个并非来自主线程的Looper或者MessageQueue时，那就没有问题。否则你需要修改你的Handler。具体步骤：</p>
<pre><code>1. 将Handler声明为静态类，
2. 当你的Handler类需要引用外部类的成员时，使用WeakReference弱引用来获得它们。
</code></pre><p>  具体改造后，就变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">    private TextView mTextView;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        mTextView = new TextView(this);</span><br><span class="line">        mTextView.setText(&quot;有内存泄露&quot;);</span><br><span class="line">        setContentView(mTextView);</span><br><span class="line">        UiHandler handler = new UiHandler(mTextView);</span><br><span class="line">        handler.sendEmptyMessage(0x11);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class UiHandler extends Handler &#123;</span><br><span class="line">        WeakReference&lt;MainActivity&gt; mActivity;</span><br><span class="line"></span><br><span class="line">        UiHandler(MainActivity activity) &#123;</span><br><span class="line">            mActivity = new WeakReference&lt;MainActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            TextView textView = mActivity.get().mTextView;</span><br><span class="line">            if (textView != null) &#123;</span><br><span class="line">                textView.setText(&quot;无内存泄漏&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为以上代码作以下几点解释：<br>1、上述Handler的作用，是在无内存泄漏的情况下，为外部Activity的mTextView设置文本信息。<br>2、静态类不持有外部类的对象，所以外部Activity可以随意被回收，不会因delay的Message持有了Handler的引用，而Handler又持有Activity的引用，导致Activity被关闭后无法被GC回收。多次的打开和关闭，会造成OOM。<br>3、WeakReference是弱引用类型，我们可以借助弱引用类型对外部非静态变量进行操作，且Handler仅有一条弱引用指向了textView，不会影响textView的回收。</p>
<h3 id="3-IntentService"><a href="#3-IntentService" class="headerlink" title="3. IntentService"></a>3. IntentService</h3><p>这是 Service 的子类，它使用工作线程逐一处理所有启动请求。如果您不要求服务同时处理多个请求，这是最好的选择。 您只需实现onHandleIntent()方法即可，该方法会接收每个启动请求的 Intent，使您能够执行后台工作。<br>以下是 IntentService 的实现示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class HelloIntentService extends IntentService &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * A constructor is required, and must call the super IntentService(String)</span><br><span class="line">   * constructor with a name for the worker thread.</span><br><span class="line">   */</span><br><span class="line">  public HelloIntentService() &#123;</span><br><span class="line">      super(&quot;HelloIntentService&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * The IntentService calls this method from the default worker thread with</span><br><span class="line">   * the intent that started the service. When this method returns, IntentService</span><br><span class="line">   * stops the service, as appropriate.</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  protected void onHandleIntent(Intent intent) &#123;</span><br><span class="line">      // Normally we would do some work here, like download a file.</span><br><span class="line">      // For our sample, we just sleep for 5 seconds.</span><br><span class="line">      long endTime = System.currentTimeMillis() + 5*1000;</span><br><span class="line">      while (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">          synchronized (this) &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                  wait(endTime - System.currentTimeMillis());</span><br><span class="line">              &#125; catch (Exception e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>您只需要一个构造函数和一个 onHandleIntent() 实现即可。<br>IntentService内部使用Handler来实现，以下提供了Service类实现与IntentService相同功能的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">public class HelloService extends Service &#123;</span><br><span class="line">  private Looper mServiceLooper;</span><br><span class="line">  private ServiceHandler mServiceHandler;</span><br><span class="line"></span><br><span class="line">  // Handler that receives messages from the thread</span><br><span class="line">  private final class ServiceHandler extends Handler &#123;</span><br><span class="line">      public ServiceHandler(Looper looper) &#123;</span><br><span class="line">          super(looper);</span><br><span class="line">      &#125;</span><br><span class="line">      @Override</span><br><span class="line">      public void handleMessage(Message msg) &#123;</span><br><span class="line">          // Normally we would do some work here, like download a file.</span><br><span class="line">          // For our sample, we just sleep for 5 seconds.</span><br><span class="line">          long endTime = System.currentTimeMillis() + 5*1000;</span><br><span class="line">          while (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">              synchronized (this) &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      wait(endTime - System.currentTimeMillis());</span><br><span class="line">                  &#125; catch (Exception e) &#123;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          // Stop the service using the startId, so that we don&apos;t stop</span><br><span class="line">          // the service in the middle of handling another job</span><br><span class="line">          stopSelf(msg.arg1);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onCreate() &#123;</span><br><span class="line">    // Start up the thread running the service.  Note that we create a</span><br><span class="line">    // separate thread because the service normally runs in the process&apos;s</span><br><span class="line">    // main thread, which we don&apos;t want to block.  We also make it</span><br><span class="line">    // background priority so CPU-intensive work will not disrupt our UI.</span><br><span class="line">    HandlerThread thread = new HandlerThread(&quot;ServiceStartArguments&quot;,</span><br><span class="line">            Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    // Get the HandlerThread&apos;s Looper and use it for our Handler</span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = new ServiceHandler(mServiceLooper);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">      Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">      // For each start request, send a message to start a job and deliver the</span><br><span class="line">      // start ID so we know which request we&apos;re stopping when we finish the job</span><br><span class="line">      Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">      msg.arg1 = startId;</span><br><span class="line">      mServiceHandler.sendMessage(msg);</span><br><span class="line"></span><br><span class="line">      // If we get killed, after returning from here, restart</span><br><span class="line">      return START_STICKY;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public IBinder onBind(Intent intent) &#123;</span><br><span class="line">      // We don&apos;t provide binding, so return null</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void onDestroy() &#123;</span><br><span class="line">    Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>正如您所见，与使用 IntentService 相比，这需要执行更多工作。<br>但是，因为是由您自己处理对 onStartCommand() 的每个调用，因此可以同时执行多个请求。此示例并未这样做，但如果您希望如此，则可为每个请求创建一个新线程，然后立即运行这些线程（而不是等待上一个请求完成）。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/android/" rel="tag">#android</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/07/24/android-interview-questions4-animation/" rel="next" title="Android面试题（四）——动画">
                <i class="fa fa-chevron-left"></i> Android面试题（四）——动画
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/07/29/android-interview-questions5-handler/"
     data-title="Android面试题（五）———— Android的消息机制"
     data-content=""
     data-url="http://yoursite.com/2016/07/29/android-interview-questions5-handler/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/07/29/android-interview-questions5-handler/"
           data-title="Android面试题（五）———— Android的消息机制" data-url="http://yoursite.com/2016/07/29/android-interview-questions5-handler/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar3.png"
               alt="郑永欣" />
          <p class="site-author-name" itemprop="name">郑永欣</p>
          <p class="site-description motion-element" itemprop="description">永远欣欣向荣的永欣</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">5</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yoxin" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Android的消息机制整体剖析"><span class="nav-number">2.</span> <span class="nav-text">Android的消息机制整体剖析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#源码分析"><span class="nav-number">3.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ThreadLocal的工作原理"><span class="nav-number">3.1.</span> <span class="nav-text">1. ThreadLocal的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-消息队列的工作原理"><span class="nav-number">3.2.</span> <span class="nav-text">2. 消息队列的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Looper的工作原理"><span class="nav-number">3.3.</span> <span class="nav-text">3. Looper的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Handler的工作原理"><span class="nav-number">3.4.</span> <span class="nav-text">4. Handler的工作原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handler的实际应用"><span class="nav-number">4.</span> <span class="nav-text">Handler的实际应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Looper和Handler的同步关系"><span class="nav-number">4.1.</span> <span class="nav-text">1. Looper和Handler的同步关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-小心内存泄露"><span class="nav-number">4.2.</span> <span class="nav-text">2. 小心内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-IntentService"><span class="nav-number">4.3.</span> <span class="nav-text">3. IntentService</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郑永欣</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"yoxin"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("7phqFwM6z0QyI5Ykuo3XEzTR-gzGzoHsz", "ogJV4H6ww1iz1kTRrPBgUv7T");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

</body>
</html>
